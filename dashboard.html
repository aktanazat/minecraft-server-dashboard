<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Minecraft Server</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #111;
  --bg-raised: #1a1a1a;
  --bg-input: #0f0f0f;
  --border: #2a2a2a;
  --text: #ddd;
  --text-dim: #888;
  --accent: #4a9eff;
  --green: #4ad679;
  --red: #ff6078;
}

html, body { height: 100%; }

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  background: var(--bg);
  color: var(--text);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  font-size: 13px;
}

.header {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 0 12px;
  height: 42px;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  background: #161616;
}

.header h1 { font-size: 14px; font-weight: 600; white-space: nowrap; }
.bi { font-size: 12px; }

.dot {
  width: 7px; height: 7px; border-radius: 50%;
  background: var(--red);
  flex-shrink: 0;
}
.dot.on { background: var(--green); box-shadow: 0 0 6px var(--green); }

.meta { color: var(--text-dim); font-size: 12px; white-space: nowrap; }
.spacer { flex: 1; }
.header-btns { display: flex; gap: 6px; }
.header-btns button .bi { margin-right: 5px; }

button {
  font-family: inherit;
  font-size: 12px;
  cursor: pointer;
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 5px 12px;
  background: rgba(255,255,255,0.03);
  color: var(--text);
  transition: border-color 0.15s, background 0.15s, opacity 0.15s;
}
button:hover { border-color: #4a5e93; background: rgba(255,255,255,0.06); }
button:disabled { opacity: 0.3; cursor: default; }
button:disabled:hover { border-color: var(--border); }

.btn-fill { background: var(--text); color: var(--bg); border-color: transparent; }
.btn-fill:hover { opacity: 0.85; }
.btn-red { border-color: var(--red); color: var(--red); }
.btn-red:hover { background: var(--red); color: #fff; }

.tabs {
  display: flex;
  gap: 0;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
  padding: 0 10px;
  background: #131313;
}

.tabs button {
  border: 1px solid transparent;
  border-radius: 8px 8px 0 0;
  padding: 8px 10px;
  color: var(--text-dim);
  border-bottom: 2px solid transparent;
  font-size: 12px;
  display: inline-flex;
  align-items: center;
  gap: 6px;
  margin-right: 2px;
}
.tabs button:hover { color: var(--text); border-color: var(--border); background: rgba(255,255,255,0.03); }
.tabs button.active { color: #fff; border-color: var(--border); border-bottom-color: var(--accent); background: rgba(255,255,255,0.06); }

.content { flex: 1; overflow: hidden; }

.panel {
  display: none;
  height: 100%;
  flex-direction: column;
  overflow: hidden;
}
.panel.active { display: flex; }
.panel.active .pbody { background: #121212; }

#console-output {
  flex: 1;
  overflow-y: auto;
  padding: 10px 12px;
  font-family: 'SF Mono', 'Fira Code', Consolas, monospace;
  font-size: 12px;
  line-height: 1.7;
  white-space: pre-wrap;
  word-break: break-all;
}

#console-output div { color: var(--text-dim); }
#console-output .c-info { color: var(--text); }
#console-output .c-warn { color: #da3; }
#console-output .c-err { color: var(--red); }
#console-output .c-join { color: var(--green); }
#console-output .c-leave { color: #a66; }
#console-output .c-cmd { color: var(--accent); }
#console-output .c-dash { color: #88f; }

.cmd-bar {
  display: flex;
  align-items: center;
  border-top: 1px solid var(--border);
  padding: 0 12px;
  height: 36px;
  flex-shrink: 0;
}

.cmd-bar span {
  color: var(--text-dim);
  font-family: monospace;
  margin-right: 8px;
  user-select: none;
}

.cmd-bar input {
  flex: 1;
  background: transparent;
  border: none;
  color: var(--text);
  font-family: 'SF Mono', 'Fira Code', Consolas, monospace;
  font-size: 12px;
  outline: none;
}

.pbody {
  flex: 1;
  overflow-y: auto;
  padding: 14px;
  max-width: none;
}

.section {
  margin-bottom: 14px;
  background: #171717;
  border: 1px solid #2b2b2b;
  border-radius: 10px;
  padding: 10px;
}
.section-title {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  color: var(--text-dim);
  margin-bottom: 8px;
}

.list-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 5px 0;
  border-bottom: 1px solid #2b2b2b;
}
.list-item:last-child { border-bottom: none; }
.list-item .name { font-weight: 500; }
.list-item .sub { font-size: 11px; color: var(--text-dim); }
.list-item .actions { display: flex; gap: 4px; }

.player-row {
  display: flex;
  align-items: center;
  gap: 8px;
}

.player-face {
  width: 18px;
  height: 18px;
  border-radius: 3px;
  image-rendering: pixelated;
  border: 1px solid var(--border);
  background: #1c1c1c;
}

.player-name-btn {
  color: var(--text);
  background: transparent;
  border: none;
  padding: 0;
  font: inherit;
  cursor: pointer;
}

.player-name-btn:hover {
  color: #fff;
  text-decoration: underline;
}

.add-row { display: flex; gap: 6px; margin-top: 8px; }

input[type="text"] {
  padding: 5px 8px;
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--text);
  font-size: 12px;
  font-family: inherit;
  outline: none;
}
input[type="text"]:focus { border-color: #444; }

.empty { padding: 20px 0; color: var(--text-dim); font-size: 12px; }

.sgrid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }

.sitem label { display: block; font-size: 11px; color: var(--text-dim); margin-bottom: 3px; }

.sitem input,
.sitem select {
  width: 100%;
  padding: 5px 8px;
  background: var(--bg-input);
  border: 1px solid var(--border);
  border-radius: 4px;
  color: var(--text);
  font-size: 12px;
  font-family: inherit;
  outline: none;
}
.sitem input:focus, .sitem select:focus { border-color: #444; }
.sitem select { cursor: pointer; }
.sitem select option { background: var(--bg); }

.toast {
  position: fixed;
  top: 12px;
  right: 12px;
  padding: 8px 14px;
  border-radius: 4px;
  font-size: 12px;
  z-index: 100;
  background: var(--bg-raised);
  border: 1px solid var(--border);
  animation: fadeIn 0.2s ease;
}
.toast.join { border-color: var(--green); }
.toast.leave { border-color: var(--red); }

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(-8px); }
  to { opacity: 1; transform: translateY(0); }
}

canvas#playerChart {
  width: 100%;
  height: 160px;
  border: 1px solid var(--border);
  border-radius: 4px;
}

.stats { display: flex; gap: 20px; margin-bottom: 12px; }
.stat .val { font-size: 22px; font-weight: 600; }
.stat .lbl { font-size: 11px; color: var(--text-dim); margin-top: 2px; }

/* Map */
.map-wrap {
  position: relative;
  flex: 1;
  overflow: hidden;
  margin: 0;
}

#mapCanvas {
  width: 100%;
  height: 100%;
  cursor: grab;
  image-rendering: pixelated;
}

#mapCanvas:active { cursor: grabbing; }

.map-hud {
  position: absolute;
  bottom: 10px;
  left: 10px;
  font-size: 11px;
  color: var(--text-dim);
  font-family: monospace;
  pointer-events: none;
  background: rgba(0,0,0,0.6);
  padding: 4px 8px;
  border-radius: 3px;
}

.map-toolbar {
  position: absolute;
  top: 10px;
  right: 10px;
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
  max-width: 60%;
  justify-content: flex-end;
}

.map-toolbar button {
  padding: 4px 8px;
  font-size: 11px;
}

.map-jump {
  display: flex;
  align-items: center;
  gap: 4px;
  background: #121212;
  border: 1px solid #363636;
  border-radius: 8px;
  padding: 3px 5px;
}

.map-jump input {
  width: 72px;
  background: #111;
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--text);
  font-size: 11px;
  padding: 2px 4px;
}

.map-layers {
  position: absolute;
  top: 10px;
  left: 10px;
  display: flex;
  gap: 8px;
  align-items: center;
  background: rgba(18,18,18,0.95);
  border: 1px solid #3a3a3a;
  border-radius: 8px;
  padding: 5px 8px;
  font-size: 11px;
}

.map-layers label {
  display: flex;
  align-items: center;
  gap: 5px;
  color: var(--text-dim);
  user-select: none;
}

.map-layers select {
  background: #101010;
  border: 1px solid var(--border);
  color: var(--text);
  border-radius: 4px;
  padding: 2px 6px;
  font-size: 11px;
}

.map-loading {
  position: absolute;
  top: 44px;
  left: 10px;
  font-size: 11px;
  color: var(--text-dim);
  font-family: monospace;
  background: rgba(16,16,16,0.92);
  padding: 4px 8px;
  border-radius: 3px;
  display: none;
}

.map-info {
  position: absolute;
  right: 10px;
  bottom: 10px;
  background: rgba(16,16,16,0.92);
  border: 1px solid #363636;
  border-radius: 8px;
  padding: 6px 8px;
  font-family: monospace;
  font-size: 11px;
  color: var(--text-dim);
  line-height: 1.4;
  pointer-events: none;
}

.modal-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 300;
}

.modal {
  width: min(760px, calc(100vw - 20px));
  max-height: calc(100vh - 20px);
  overflow: auto;
  background: #141414;
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 12px;
}

.modal-head {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 10px;
}

.modal-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
}

.modal-card {
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 10px;
  background: #101010;
}

.modal-card .section-title {
  margin-bottom: 6px;
}

.inv-mc {
  display: grid;
  gap: 6px;
}

.inv-title-row {
  font-size: 10px;
  color: #b6b6b6;
  text-transform: uppercase;
  letter-spacing: 0.06em;
  font-family: monospace;
}

.inv-grid {
  display: grid;
  grid-template-columns: repeat(9, 40px);
  gap: 3px;
  width: fit-content;
}

.inv-grid-small {
  display: grid;
  grid-template-columns: 40px;
  grid-auto-rows: 40px;
  gap: 3px;
  width: fit-content;
}

.inv-mc-shell {
  display: flex;
  gap: 8px;
  align-items: flex-start;
  background: #8b8b8b;
  border: 2px solid #3a3a3a;
  box-shadow:
    inset 0 0 0 2px #bdbdbd,
    inset 0 -2px 0 0 #5a5a5a;
  padding: 8px;
  width: fit-content;
}

.inv-mc-right {
  display: grid;
  gap: 6px;
}

.inv-slot {
  width: 40px;
  height: 40px;
  background: #8b8b8b;
  border: none;
  box-shadow:
    inset -2px -2px 0 0 #3b3b3b,
    inset 2px 2px 0 0 #ffffff99;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.inv-slot:hover {
  outline: 1px solid #f2f2f2;
  outline-offset: -1px;
}

.inv-slot.selected {
  outline: 2px solid #fff;
  outline-offset: -2px;
}

.inv-icon {
  width: 26px;
  height: 26px;
  image-rendering: pixelated;
}

.inv-fallback {
  color: #d7d7d7;
  font-size: 14px;
}

.inv-count {
  position: absolute;
  right: 3px;
  bottom: 1px;
  font-size: 11px;
  color: #fff;
  text-shadow: 1px 1px 0 #000;
  font-family: monospace;
}

.inv-tooltip {
  position: fixed;
  z-index: 450;
  pointer-events: none;
  display: none;
  background: rgba(0, 0, 0, 0.95);
  border: 1px solid #4a4a4a;
  border-radius: 6px;
  padding: 6px 8px;
  min-width: 120px;
  max-width: 280px;
  color: #f4f4f4;
  box-shadow: 0 6px 18px rgba(0, 0, 0, 0.5);
}

.inv-tooltip .t-name {
  font-size: 12px;
  font-weight: 600;
  margin-bottom: 2px;
}

.inv-tooltip .t-sub {
  font-size: 11px;
  color: #b9b9b9;
  font-family: monospace;
}
</style>
</head>
<body>

<div class="header">
  <h1><i class="bi bi-controller"></i> Minecraft Server</h1>
  <div class="dot" id="dot"></div>
  <span class="meta" id="statusMeta">Stopped</span>
  <span class="meta" id="perfMeta"></span>
  <span class="spacer"></span>
  <div class="header-btns">
    <button class="btn-fill" id="btnStart" onclick="startServer()"><i class="bi bi-play-fill"></i>Start</button>
    <button id="btnStop" onclick="stopServer()" disabled><i class="bi bi-stop-fill"></i>Stop</button>
    <button id="btnRestart" onclick="restartServer()" disabled><i class="bi bi-arrow-clockwise"></i>Restart</button>
  </div>
</div>

<div class="tabs">
  <button class="active" data-tab="console"><i class="bi bi-terminal"></i>Console</button>
  <button data-tab="players"><i class="bi bi-people"></i>Players</button>
  <button data-tab="world"><i class="bi bi-globe2"></i>World</button>
  <button data-tab="settings"><i class="bi bi-sliders2"></i>Settings</button>
  <button data-tab="map"><i class="bi bi-map"></i>Map</button>
  <button data-tab="stats"><i class="bi bi-graph-up-arrow"></i>Stats</button>
</div>

<div class="content">
  <div class="panel active" id="tab-console">
    <div id="console-output"></div>
    <div class="cmd-bar">
      <span>/</span>
      <input type="text" id="cmdInput" placeholder="command" autocomplete="off" />
    </div>
  </div>

  <div class="panel" id="tab-players">
    <div class="pbody">
      <div class="section">
        <div class="section-title">Online</div>
        <div id="onlinePlayers"><div class="empty">No players online</div></div>
      </div>
      <div class="section">
        <div class="section-title">Whitelist</div>
        <div id="whitelistList"></div>
        <div class="add-row">
          <input type="text" id="wlInput" placeholder="Player name" style="flex:1" />
          <button onclick="addWhitelist()">Add</button>
        </div>
      </div>
      <div class="section">
        <div class="section-title">Operators</div>
        <div id="opsList"></div>
        <div class="add-row">
          <input type="text" id="opsInput" placeholder="Player name" style="flex:1" />
          <button onclick="addOp()">Add</button>
        </div>
      </div>
      <div class="section">
        <div class="section-title">Banned</div>
        <div id="bannedList"></div>
        <div class="add-row">
          <input type="text" id="banInput" placeholder="Player name" style="flex:1" />
          <button class="btn-red" onclick="addBan()">Ban</button>
        </div>
      </div>
    </div>
  </div>

  <div class="panel" id="tab-world">
    <div class="pbody">
      <div class="section">
        <div class="section-title">New World</div>
        <p style="color:var(--text-dim);margin-bottom:8px;">Backs up the current world, then generates a new one.</p>
        <div class="add-row">
          <input type="text" id="seedInput" placeholder="Seed (optional)" style="flex:1" />
          <button onclick="generateNewWorld()">Generate</button>
        </div>
      </div>
      <div class="section">
        <div class="section-title">Backups</div>
        <div id="backupsList"><div class="empty">No backups</div></div>
      </div>
      <div class="section">
        <div class="section-title">World Info</div>
        <div id="worldInfo" class="empty">Loading...</div>
      </div>
    </div>
  </div>

  <div class="panel" id="tab-settings">
    <div class="pbody">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;">
        <div class="section-title" style="margin:0">Server Properties</div>
        <button class="btn-fill" onclick="saveSettings()">Save</button>
      </div>
      <div class="section">
        <div class="section-title">General</div>
        <div class="sgrid" id="settingsGeneral"></div>
      </div>
      <div class="section">
        <div class="section-title">Gameplay</div>
        <div class="sgrid" id="settingsGameplay"></div>
      </div>
      <div class="section">
        <div class="section-title">Network</div>
        <div class="sgrid" id="settingsNetwork"></div>
      </div>
      <div class="section">
        <div class="section-title">Performance</div>
        <div class="sgrid" id="settingsPerformance"></div>
      </div>
    </div>
  </div>

  <div class="panel" id="tab-map">
    <div class="map-wrap">
      <canvas id="mapCanvas"></canvas>
      <div class="map-hud" id="mapHud">0, 0</div>
      <div class="map-layers">
        <label>
          Map
          <select id="mapMode">
            <option value="world">explored</option>
            <option value="seed">seed preview</option>
          </select>
        </label>
        <label><input type="checkbox" id="togglePlayers" checked />Players</label>
        <label><input type="checkbox" id="toggleVillages" checked />Villages</label>
        <label><input type="checkbox" id="toggleStructures" checked />Structures</label>
        <label><input type="checkbox" id="toggleSpawners" />Dungeons</label>
        <label><input type="checkbox" id="toggleSpawn" checked />Spawn</label>
        <label><input type="checkbox" id="toggleRespawns" />Respawns</label>
        <label>
          Follow
          <select id="followPlayer">
            <option value="">none</option>
          </select>
        </label>
      </div>
      <div class="map-loading" id="mapLoading">Loading tiles...</div>
      <div class="map-toolbar">
        <button onclick="mapZoomIn()">+</button>
        <button onclick="mapZoomOut()">-</button>
        <button onclick="mapReset()">Reset</button>
        <button onclick="mapFit()">Fit</button>
        <button onclick="mapJump()">Go</button>
        <button onclick="mapRefresh()">Reload</button>
        <button onclick="mapGenerateAll()">Generate All</button>
        <button onclick="mapFullscreen()">Fullscreen</button>
        <div class="map-jump">
          <input id="jumpX" placeholder="X" />
          <input id="jumpZ" placeholder="Z" />
        </div>
      </div>
      <div class="map-info" id="mapInfo">regions: 0 | players: 0 | villages: 0</div>
    </div>
  </div>

  <div class="panel" id="tab-stats">
    <div class="pbody">
      <div class="stats">
        <div class="stat">
          <div class="val" id="statUptime">--</div>
          <div class="lbl">Uptime</div>
        </div>
        <div class="stat">
          <div class="val" id="statPlayers">0</div>
          <div class="lbl">Players</div>
        </div>
        <div class="stat">
          <div class="val" id="statMax">20</div>
          <div class="lbl">Max</div>
        </div>
      </div>
      <div class="section">
        <div class="section-title">Player count</div>
        <canvas id="playerChart"></canvas>
      </div>
    </div>
  </div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
const socket = io();
let status = { running: false, uptime: 0, playerCount: 0, players: [], maxPlayers: 20, tps: null, mspt: null };
let autoScroll = true;
let cmdHistory = [];
let histIdx = -1;
let props = {};
let mapActive = false;
const TAB_KEY = 'dashboard.activeTab';
let activePlayer = '';

// Fetch status on connect/reconnect to fix stale state on page reload
socket.on('connect', async () => {
  try {
    const res = await fetch('/api/status');
    status = await res.json();
    updateUI();
  } catch {}
});

function openTab(tab) {
  const tabName = tab || 'console';
  const button = document.querySelector(`.tabs button[data-tab="${tabName}"]`);
  if (!button) return;
  document.querySelectorAll('.tabs button').forEach((b) => b.classList.remove('active'));
  document.querySelectorAll('.panel').forEach((p) => p.classList.remove('active'));
  button.classList.add('active');
  document.getElementById('tab-' + tabName).classList.add('active');
  localStorage.setItem(TAB_KEY, tabName);
  mapActive = tabName === 'map';
  if (!mapActive) stopMapPolling();
  if (tabName === 'players') loadPlayers();
  if (tabName === 'world') { loadWorlds(); loadWorldInfo(); }
  if (tabName === 'settings') loadSettings();
  if (tabName === 'stats') loadPerf();
  if (tabName === 'map') initMap();
}

document.querySelectorAll('.tabs button').forEach((btn) => {
  btn.addEventListener('click', () => openTab(btn.dataset.tab));
});

// Console
const out = document.getElementById('console-output');
const cmd = document.getElementById('cmdInput');

function cls(line) {
  if (line.startsWith('[Dashboard]')) return 'c-dash';
  if (line.startsWith('>')) return 'c-cmd';
  if (/joined the game/.test(line)) return 'c-join';
  if (/left the game/.test(line)) return 'c-leave';
  if (/WARN/.test(line)) return 'c-warn';
  if (/ERROR|FATAL/.test(line)) return 'c-err';
  if (/INFO/.test(line)) return 'c-info';
  return '';
}

function esc(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }

function log(line) {
  const d = document.createElement('div');
  d.className = cls(line);
  d.textContent = line;
  out.appendChild(d);
  if (autoScroll) out.scrollTop = out.scrollHeight;
}

out.addEventListener('scroll', () => {
  autoScroll = out.scrollHeight - out.scrollTop - out.clientHeight < 40;
});

cmd.addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    const v = cmd.value.trim();
    if (!v) return;
    socket.emit('command', v);
    cmdHistory.unshift(v);
    histIdx = -1;
    cmd.value = '';
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    if (histIdx < cmdHistory.length - 1) cmd.value = cmdHistory[++histIdx];
  } else if (e.key === 'ArrowDown') {
    e.preventDefault();
    if (histIdx > 0) cmd.value = cmdHistory[--histIdx];
    else { histIdx = -1; cmd.value = ''; }
  }
});

socket.on('log', log);
socket.on('status', (s) => { status = s; updateUI(); });
socket.on('players', (d) => {
  if (d.type === 'join') toast(d.name + ' joined', 'join');
  else if (d.type === 'leave') toast(d.name + ' left', 'leave');
  if (mapInited && mapActive) refreshMapOverlays();
});

function updateUI() {
  document.getElementById('dot').className = 'dot' + (status.running ? ' on' : '');
  const parts = [];
  if (status.running) {
    parts.push(status.playerCount + '/' + status.maxPlayers + ' players');
    if (status.uptime > 0) parts.push(dur(status.uptime));
  } else {
    parts.push('Stopped');
  }
  document.getElementById('statusMeta').textContent = parts.join('  ');
  const tpsTxt = Number.isFinite(status.tps) ? status.tps.toFixed(2) : '--';
  const msptTxt = Number.isFinite(status.mspt) ? status.mspt.toFixed(1) : '--';
  document.getElementById('perfMeta').textContent = `TPS ${tpsTxt} | MSPT ${msptTxt}`;
  document.getElementById('btnStart').disabled = status.running;
  document.getElementById('btnStop').disabled = !status.running;
  document.getElementById('btnRestart').disabled = !status.running;
  document.getElementById('statUptime').textContent = status.running ? dur(status.uptime) : '--';
  document.getElementById('statPlayers').textContent = status.playerCount;
  document.getElementById('statMax').textContent = status.maxPlayers;
}

function dur(ms) {
  const s = Math.floor(ms / 1000);
  const h = Math.floor(s / 3600);
  const m = Math.floor((s % 3600) / 60);
  if (h > 0) return h + 'h ' + m + 'm';
  if (m > 0) return m + 'm ' + (s % 60) + 's';
  return (s % 60) + 's';
}

async function startServer() { document.getElementById('btnStart').disabled = true; await fetch('/api/start', { method: 'POST' }); }
async function stopServer() { document.getElementById('btnStop').disabled = true; await fetch('/api/stop', { method: 'POST' }); }
async function restartServer() { document.getElementById('btnRestart').disabled = true; await fetch('/api/restart', { method: 'POST' }); }

// Players
async function loadPlayers() {
  const data = await (await fetch('/api/players')).json();
  document.getElementById('onlinePlayers').innerHTML = data.online.length === 0
    ? '<div class="empty">No players online</div>'
    : data.online.map((n) => {
      const safe = esc(n);
      const encoded = encodeURIComponent(n);
      return `<div class="list-item"><div class="player-row"><img class="player-face" src="https://mc-heads.net/avatar/${encoded}/24" alt="${safe}" loading="lazy" /><button class="player-name-btn" onclick="openPlayerModal('${safe}')">${safe}</button></div><div class="actions"><button onclick="opPlayer('${safe}')">Op</button><button onclick="kickPlayer('${safe}')">Kick</button><button class="btn-red" onclick="banPlayer('${safe}')">Ban</button></div></div>`;
    }).join('');

  document.getElementById('whitelistList').innerHTML =
    data.whitelist.map(p => `<div class="list-item"><span class="name">${esc(p.name)}</span><button onclick="removeWhitelist('${esc(p.name)}')">Remove</button></div>`).join('') || '<div class="empty">Empty</div>';
  document.getElementById('opsList').innerHTML =
    data.ops.map(p => `<div class="list-item"><span class="name">${esc(p.name)}</span><button onclick="removeOp('${esc(p.name)}')">Remove</button></div>`).join('') || '<div class="empty">Empty</div>';
  document.getElementById('bannedList').innerHTML =
    data.banned.map(p => `<div class="list-item"><span class="name">${esc(p.name)}</span><button onclick="unban('${esc(p.name)}')">Unban</button></div>`).join('') || '<div class="empty">Empty</div>';
}

async function addWhitelist() { const i = document.getElementById('wlInput'); if (!i.value.trim()) return; await fetch('/api/whitelist', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({name:i.value.trim()}) }); i.value = ''; setTimeout(loadPlayers, 500); }
async function removeWhitelist(n) { await fetch('/api/whitelist/' + n, { method: 'DELETE' }); setTimeout(loadPlayers, 500); }
async function addOp() { const i = document.getElementById('opsInput'); if (!i.value.trim()) return; await fetch('/api/ops', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({name:i.value.trim()}) }); i.value = ''; setTimeout(loadPlayers, 500); }
async function removeOp(n) { await fetch('/api/ops/' + n, { method: 'DELETE' }); setTimeout(loadPlayers, 500); }
async function addBan() { const i = document.getElementById('banInput'); if (!i.value.trim()) return; await fetch('/api/ban', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({name:i.value.trim()}) }); i.value = ''; setTimeout(loadPlayers, 500); }
async function unban(n) { await fetch('/api/ban/' + n, { method: 'DELETE' }); setTimeout(loadPlayers, 500); }
async function kickPlayer(n) { await fetch('/api/kick', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({name:n}) }); }
async function banPlayer(n) { await fetch('/api/ban', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({name:n}) }); setTimeout(loadPlayers, 500); }
async function opPlayer(n) { await fetch('/api/ops', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({name:n}) }); setTimeout(loadPlayers, 500); }

// World
async function loadWorlds() {
  const data = await (await fetch('/api/worlds')).json();
  document.getElementById('backupsList').innerHTML = data.length === 0
    ? '<div class="empty">No backups</div>'
    : data.map(b => `<div class="list-item"><div><span class="name">${esc(b.name)}</span><div class="sub">${new Date(b.created).toLocaleString()}</div></div><div class="actions"><button onclick="restoreWorld('${esc(b.name)}')">Restore</button><button class="btn-red" onclick="deleteBackup('${esc(b.name)}')">Delete</button></div></div>`).join('');
}

async function generateNewWorld() {
  const seed = document.getElementById('seedInput').value.trim();
  if (!confirm('Back up current world and generate a new one?')) return;
  toast('Generating...', '');
  await fetch('/api/world/new', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({seed}) });
  document.getElementById('seedInput').value = '';
  setTimeout(loadWorlds, 2000);
  setTimeout(loadWorldInfo, 2200);
}

async function restoreWorld(name) {
  if (!confirm('Restore this backup?')) return;
  toast('Restoring...', '');
  await fetch('/api/world/restore/' + name, { method: 'POST' });
  setTimeout(loadWorlds, 2000);
  setTimeout(loadWorldInfo, 2200);
}

async function deleteBackup(name) {
  if (!confirm('Delete this backup permanently?')) return;
  await fetch('/api/world/backup/' + name, { method: 'DELETE' });
  loadWorlds();
  loadWorldInfo();
}

function fmtBytes(bytes) {
  const n = Number(bytes) || 0;
  if (n < 1024) return `${n} B`;
  if (n < 1024 * 1024) return `${(n / 1024).toFixed(1)} KB`;
  if (n < 1024 * 1024 * 1024) return `${(n / (1024 * 1024)).toFixed(1)} MB`;
  return `${(n / (1024 * 1024 * 1024)).toFixed(2)} GB`;
}

async function loadWorldInfo() {
  const el = document.getElementById('worldInfo');
  el.innerHTML = '<div class="empty">Loading...</div>';
  try {
    const data = await (await fetch('/api/world/info')).json();
    const seed = data.levelSeed && String(data.levelSeed).trim() ? esc(String(data.levelSeed)) : '<span class="sub">hidden/empty</span>';
    const worldSize = data.worldSizePending
      ? '<span class="sub">calculating...</span>'
      : fmtBytes(data.worldSizeBytes);
    el.innerHTML = `
      <div class="list-item"><span class="name">Level</span><span>${esc(data.levelName || 'world')}</span></div>
      <div class="list-item"><span class="name">Seed</span><span>${seed}</span></div>
      <div class="list-item"><span class="name">World Size</span><span>${worldSize}</span></div>
      <div class="list-item"><span class="name">Regions</span><span>${data.regionCount}</span></div>
      <div class="list-item"><span class="name">Backups</span><span>${data.backupCount}</span></div>
      <div class="list-item"><span class="name">Map Cache</span><span>${data.cachedTiles} tiles</span></div>
    `;
    if (data.worldSizePending) {
      setTimeout(() => {
        if (document.getElementById('tab-world').classList.contains('active')) loadWorldInfo();
      }, 1200);
    }
  } catch {
    el.innerHTML = '<div class="empty">Failed to load world info</div>';
  }
}

// Settings
const GROUPS = {
  General: ['motd','server-port','max-players','level-name','level-seed','gamemode','difficulty','hardcore','white-list','enforce-whitelist','online-mode'],
  Gameplay: ['allow-flight','spawn-protection','force-gamemode','generate-structures','max-world-size','player-idle-timeout','level-type'],
  Network: ['server-ip','network-compression-threshold','prevent-proxy-connections','enable-query','query.port','enable-rcon','rcon.port','rcon.password','rate-limit'],
  Performance: ['view-distance','simulation-distance','max-tick-time','max-chained-neighbor-updates','sync-chunk-writes','entity-broadcast-range-percentage','use-native-transport','pause-when-empty-seconds'],
};
const BOOLS = new Set(['allow-flight','force-gamemode','generate-structures','hardcore','white-list','enforce-whitelist','online-mode','prevent-proxy-connections','enable-query','enable-rcon','sync-chunk-writes','use-native-transport']);
const SELECTS = { gamemode: ['survival','creative','adventure','spectator'], difficulty: ['peaceful','easy','normal','hard'] };

async function loadSettings() {
  props = await (await fetch('/api/properties')).json();
  for (const [g, keys] of Object.entries(GROUPS)) {
    document.getElementById('settings' + g).innerHTML = keys.filter(k => k in props).map(k => {
      const v = props[k];
      if (SELECTS[k]) return `<div class="sitem"><label>${k}</label><select data-key="${k}">${SELECTS[k].map(o => `<option${o===v?' selected':''}>${o}</option>`).join('')}</select></div>`;
      if (BOOLS.has(k)) return `<div class="sitem"><label>${k}</label><select data-key="${k}"><option${v==='true'?' selected':''}>true</option><option${v==='false'?' selected':''}>false</option></select></div>`;
      return `<div class="sitem"><label>${k}</label><input data-key="${k}" value="${esc(v)}" /></div>`;
    }).join('');
  }
}

async function saveSettings() {
  const u = {};
  document.querySelectorAll('[data-key]').forEach(el => u[el.dataset.key] = el.value);
  await fetch('/api/properties', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(u) });
  toast('Saved. Restart to apply.', '');
}

// Stats
async function loadPerf() {
  const d = await (await fetch('/api/performance')).json();
  drawChart(d.playerCountHistory);
}

function drawChart(h) {
  const c = document.getElementById('playerChart');
  const ctx = c.getContext('2d');
  const dpr = devicePixelRatio || 1;
  const r = c.getBoundingClientRect();
  c.width = r.width * dpr; c.height = r.height * dpr;
  ctx.scale(dpr, dpr);
  const w = r.width, ht = r.height;
  const p = { t: 16, r: 16, b: 24, l: 32 };
  const pw = w - p.l - p.r, ph = ht - p.t - p.b;
  ctx.clearRect(0, 0, w, ht);

  if (h.length < 2) {
    ctx.fillStyle = '#666'; ctx.font = '12px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('Waiting for data...', w/2, ht/2); return;
  }

  const max = Math.max(1, ...h.map(x => x.count));
  const t0 = h[0].time, tR = h[h.length-1].time - t0 || 1;

  ctx.strokeStyle = '#222'; ctx.lineWidth = 1;
  for (let i = 0; i <= 3; i++) { const y = p.t + (ph/3)*i; ctx.beginPath(); ctx.moveTo(p.l,y); ctx.lineTo(p.l+pw,y); ctx.stroke(); }

  ctx.fillStyle = '#555'; ctx.font = '10px sans-serif'; ctx.textAlign = 'right';
  for (let i = 0; i <= 3; i++) ctx.fillText(Math.round(max*(1-i/3)), p.l-6, p.t+(ph/3)*i+3);

  ctx.strokeStyle = '#4a9eff';
  ctx.lineWidth = 1.5; ctx.lineJoin = 'round'; ctx.beginPath();
  h.forEach((pt, i) => {
    const x = p.l + ((pt.time-t0)/tR)*pw;
    const y = p.t + ph - (pt.count/max)*ph;
    i === 0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
  });
  ctx.stroke();

  ctx.lineTo(p.l+pw, p.t+ph); ctx.lineTo(p.l, p.t+ph); ctx.closePath();
  const g = ctx.createLinearGradient(0, p.t, 0, p.t+ph);
  g.addColorStop(0, 'rgba(74,158,255,0.15)'); g.addColorStop(1, 'rgba(74,158,255,0)');
  ctx.fillStyle = g; ctx.fill();
}

// --- Map ---

let mapInited = false;
let mapRegions = [];
let mapTiles = {};
let mapLoading = new Set();
let mapOverlays = { players: [], villages: [], structures: [], spawners: [], spawn: null, respawns: [] };
let mapView = { x: 0, z: 0, zoom: 1 };
let mapDrag = null;
let mapPollTimer = null;
let mapAutoTick = 0;
let mapTileVersion = 0;
let mapHasUserView = false;
let mapGeneratePollTimer = null;
let mapMode = 'world';

const mapCanvas = document.getElementById('mapCanvas');
const mapCtx = mapCanvas.getContext('2d');
const followPlayerSelect = document.getElementById('followPlayer');
const mapModeSelect = document.getElementById('mapMode');

document.getElementById('togglePlayers').addEventListener('change', () => renderMap());
document.getElementById('toggleVillages').addEventListener('change', () => renderMap());
document.getElementById('toggleStructures').addEventListener('change', () => renderMap());
document.getElementById('toggleSpawners').addEventListener('change', () => renderMap());
document.getElementById('toggleSpawn').addEventListener('change', () => renderMap());
document.getElementById('toggleRespawns').addEventListener('change', () => renderMap());
mapModeSelect.addEventListener('change', () => {
  mapMode = mapModeSelect.value;
  mapTiles = {};
  mapHasUserView = false;
  mapFitToRegions();
  renderMap();
});
followPlayerSelect.addEventListener('change', () => {
  if (followPlayerSelect.value) centerOnPlayer(followPlayerSelect.value);
});

function worldToScreen(wx, wz) {
  return [
    (wx - mapView.x) * mapView.zoom + mapCanvas.width / (2 * (devicePixelRatio || 1)),
    (wz - mapView.z) * mapView.zoom + mapCanvas.height / (2 * (devicePixelRatio || 1)),
  ];
}

function screenToWorld(sx, sz) {
  const dpr = devicePixelRatio || 1;
  return [
    (sx - mapCanvas.width / (2 * dpr)) / mapView.zoom + mapView.x,
    (sz - mapCanvas.height / (2 * dpr)) / mapView.zoom + mapView.z,
  ];
}

async function initMap() {
  if (!mapInited) {
    mapInited = true;
    mapCanvas.addEventListener('mousedown', onMapMouseDown);
    mapCanvas.addEventListener('mousemove', onMapMouseMove);
    mapCanvas.addEventListener('mouseup', onMapMouseUp);
    mapCanvas.addEventListener('mouseleave', onMapMouseUp);
    mapCanvas.addEventListener('wheel', onMapWheel, { passive: false });
    window.addEventListener('resize', renderMap);
  }
  await refreshMapData({ fit: !mapHasUserView, hardRefresh: false });
  startMapPolling();
}

function startMapPolling() {
  stopMapPolling();
  mapAutoTick = 0;
  mapPollTimer = setInterval(() => {
    if (!mapActive) return;
    mapAutoTick++;
    const refreshTiles = mapAutoTick % 6 === 0;
    refreshMapData({ fit: false, hardRefresh: refreshTiles });
  }, 5000);
}

function stopMapPolling() {
  if (mapPollTimer) {
    clearInterval(mapPollTimer);
    mapPollTimer = null;
  }
}

async function refreshMapData({ fit, hardRefresh }) {
  if (hardRefresh) {
    mapTileVersion++;
    mapTiles = {};
    await fetch('/api/map/clear-cache', { method: 'POST' });
  }
  const [regionsRes, overlaysRes] = await Promise.all([
    fetch('/api/map/regions'),
    fetch('/api/map/overlays'),
  ]);
  mapRegions = await regionsRes.json();
  mapOverlays = await overlaysRes.json();
  updateFollowPlayerOptions();
  if (fit) mapFitToRegions();
  if (followPlayerSelect.value) centerOnPlayer(followPlayerSelect.value);
  renderMap();
}

function onMapMouseDown(e) {
  mapDrag = { sx: e.clientX, sz: e.clientY, ox: mapView.x, oz: mapView.z };
  mapHasUserView = true;
  mapCanvas.style.cursor = 'grabbing';
}

function onMapMouseMove(e) {
  const rect = mapCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const mz = e.clientY - rect.top;
  const [wx, wz] = screenToWorld(mx, mz);
  document.getElementById('mapHud').textContent = `${Math.round(wx)}, ${Math.round(wz)}  [${mapView.zoom.toFixed(2)}x]`;

  if (mapDrag) {
    const dx = (e.clientX - mapDrag.sx) / mapView.zoom;
    const dz = (e.clientY - mapDrag.sz) / mapView.zoom;
    mapView.x = mapDrag.ox - dx;
    mapView.z = mapDrag.oz - dz;
    renderMap();
  }
}

function onMapMouseUp() {
  mapDrag = null;
  mapCanvas.style.cursor = 'grab';
}

function onMapWheel(e) {
  e.preventDefault();
  const factor = e.deltaY > 0 ? 0.8 : 1.25;
  mapView.zoom = Math.max(0.05, Math.min(8, mapView.zoom * factor));
  mapHasUserView = true;
  renderMap();
}

function mapZoomIn() { mapView.zoom = Math.min(8, mapView.zoom * 1.5); mapHasUserView = true; renderMap(); }
function mapZoomOut() { mapView.zoom = Math.max(0.05, mapView.zoom / 1.5); mapHasUserView = true; renderMap(); }
function mapReset() { mapHasUserView = false; mapFitToRegions(); renderMap(); }
function mapFit() { mapHasUserView = false; mapFitToRegions(); renderMap(); }

async function mapRefresh() {
  mapHasUserView = false;
  mapTiles = {};
  mapTileVersion++;
  await requestLivePlayerPositions();
  await refreshMapData({ fit: true, hardRefresh: true });
}

function mapJump() {
  const x = Number(document.getElementById('jumpX').value);
  const z = Number(document.getElementById('jumpZ').value);
  if (!Number.isFinite(x) || !Number.isFinite(z)) return;
  mapView.x = x;
  mapView.z = z;
  mapView.zoom = Math.max(mapView.zoom, 0.7);
  mapHasUserView = true;
  renderMap();
}

async function mapGenerateAll() {
  await fetch('/api/map/generate-all', { method: 'POST' });
  if (mapGeneratePollTimer) clearInterval(mapGeneratePollTimer);
  mapGeneratePollTimer = setInterval(async () => {
    const s = await (await fetch('/api/map/generate-status')).json();
    const loading = document.getElementById('mapLoading');
    if (s.running) {
      loading.style.display = 'block';
      loading.textContent = `Generating map tiles ${s.done}/${s.total}...`;
      return;
    }
    clearInterval(mapGeneratePollTimer);
    mapGeneratePollTimer = null;
    loading.style.display = 'none';
    loading.textContent = 'Loading tiles...';
    await refreshMapData({ fit: false, hardRefresh: false });
  }, 1200);
}

function mapFullscreen() {
  if (!document.fullscreenElement) {
    document.getElementById('tab-map').requestFullscreen().catch(() => {});
  } else {
    document.exitFullscreen().catch(() => {});
  }
}

async function apiJson(url, opts) {
  const res = await fetch(url, opts);
  let data = null;
  try {
    data = await res.json();
  } catch {}
  if (!res.ok || (data && data.error)) {
    const message = (data && data.error) ? data.error : `Request failed (${res.status})`;
    throw new Error(message);
  }
  return data;
}

function closePlayerModal() {
  document.getElementById('playerModalBackdrop').style.display = 'none';
  activePlayer = '';
}

function itemDisplayName(id) {
  const raw = String(id || '');
  const base = raw.includes(':') ? raw.split(':').pop() : raw;
  return base.split('_').map((p) => p ? p[0].toUpperCase() + p.slice(1) : '').join(' ');
}

function itemIconUrl(id) {
  const raw = String(id || '');
  const base = raw.includes(':') ? raw.split(':').pop() : raw;
  return `/api/item-icon/${encodeURIComponent(base)}`;
}

function normalizeSlot(raw) {
  let slot = Number(raw);
  if (!Number.isFinite(slot)) return null;
  if (slot < 0) slot += 256;
  return slot;
}

function tooltipAttr(name, id, count) {
  return `data-tip-name="${esc(name)}" data-tip-id="${esc(id)}" data-tip-count="${count}"`;
}

function renderInventoryMinecraft(items, selectedSlot) {
  const bySlot = new Map();
  for (const it of items) {
    const slot = normalizeSlot(it.slot);
    if (slot === null) continue;
    bySlot.set(slot, it);
  }

  const renderSlot = (slot, label) => {
    const it = bySlot.get(slot);
    const selected = slot === selectedSlot ? ' selected' : '';
    if (!it) return `<div class="inv-slot${selected}" title="${esc(label)}"></div>`;
    const title = `${itemDisplayName(it.id)} x${it.count} (${it.id})`;
    const tip = tooltipAttr(itemDisplayName(it.id), it.id, it.count);
    return `
      <div class="inv-slot${selected}" title="${esc(title)}" ${tip}>
        <img class="inv-icon" src="${itemIconUrl(it.id)}" alt="${esc(it.id)}" loading="lazy" onerror="this.style.display='none';this.nextElementSibling.style.display='inline-block'" />
        <i class="bi bi-box-seam inv-fallback" style="display:none"></i>
        ${it.count > 1 ? `<span class="inv-count">${it.count}</span>` : ''}
      </div>
    `;
  };

  const mainRows = [
    [9,10,11,12,13,14,15,16,17],
    [18,19,20,21,22,23,24,25,26],
    [27,28,29,30,31,32,33,34,35],
  ];
  const hotbar = [0,1,2,3,4,5,6,7,8];
  const equip = [
    { slot: 100, label: 'Boots' },
    { slot: 101, label: 'Leggings' },
    { slot: 102, label: 'Chestplate' },
    { slot: 103, label: 'Helmet' },
    { slot: 150, label: 'Offhand' },
  ];

  return `
    <div class="inv-mc">
      <div class="inv-title-row">Inventory</div>
      <div class="inv-mc-shell">
        <div class="inv-grid-small">${equip.map((e) => renderSlot(e.slot, e.label)).join('')}</div>
        <div class="inv-mc-right">
          <div class="inv-grid">${mainRows.flat().map((s) => renderSlot(s, `Slot ${s}`)).join('')}</div>
          <div class="inv-grid">${hotbar.map((s) => renderSlot(s, `Hotbar ${s}`)).join('')}</div>
        </div>
      </div>
    </div>
  `;
}

function bindInventoryTooltips() {
  const tooltip = document.getElementById('invTooltip');
  const container = document.getElementById('pmInventory');
  if (!tooltip || !container) return;

  const show = (e) => {
    const slot = e.target.closest('.inv-slot[data-tip-name]');
    if (!slot) return;
    const name = slot.getAttribute('data-tip-name') || '';
    const id = slot.getAttribute('data-tip-id') || '';
    const count = slot.getAttribute('data-tip-count') || '1';
    tooltip.innerHTML = `<div class="t-name">${name}</div><div class="t-sub">${id} x${count}</div>`;
    tooltip.style.display = 'block';
    move(e);
  };

  const move = (e) => {
    if (tooltip.style.display !== 'block') return;
    const x = e.clientX + 14;
    const y = e.clientY + 14;
    tooltip.style.left = `${x}px`;
    tooltip.style.top = `${y}px`;
  };

  const hide = () => {
    tooltip.style.display = 'none';
  };

  container.addEventListener('mouseover', show);
  container.addEventListener('mousemove', move);
  container.addEventListener('mouseout', hide);
}

async function openPlayerModal(name) {
  activePlayer = name;
  document.getElementById('playerModalBackdrop').style.display = 'flex';
  document.getElementById('pmName').textContent = name;
  document.getElementById('pmFace').src = `https://mc-heads.net/avatar/${encodeURIComponent(name)}/32`;
  document.getElementById('pmOverview').innerHTML = '<div class="empty">Loading...</div>';
  document.getElementById('pmInventory').innerHTML = '<div class="empty">Loading...</div>';
  try {
    const d = await (await fetch('/api/player/' + encodeURIComponent(name))).json();
    if (!d || d.error) {
      document.getElementById('pmOverview').innerHTML = `<div class="empty">${esc(d?.error || 'Player data unavailable')}</div>`;
      document.getElementById('pmInventory').innerHTML = '<div class="empty">No inventory data</div>';
      return;
    }
    document.getElementById('pmOverview').innerHTML = `
      <div class="list-item"><span class="name">Online</span><span>${d.online ? 'yes' : 'no'}</span></div>
      <div class="list-item"><span class="name">Dimension</span><span>${esc(d.position.dimension)}</span></div>
      <div class="list-item"><span class="name">Pos</span><span>${Math.round(d.position.x)}, ${Math.round(d.position.y)}, ${Math.round(d.position.z)}</span></div>
      <div class="list-item"><span class="name">Health</span><span>${d.stats.health}</span></div>
      <div class="list-item"><span class="name">Food</span><span>${d.stats.food}</span></div>
      <div class="list-item"><span class="name">XP</span><span>Lv ${d.stats.xpLevel} (${d.stats.xpTotal})</span></div>
      <div class="list-item"><span class="name">Gamemode</span><span>${d.stats.gameType}</span></div>
    `;
    if (!d.inventory || d.inventory.length === 0) {
      document.getElementById('pmInventory').innerHTML = '<div class="empty">No items in snapshot</div>';
    } else {
      document.getElementById('pmInventory').innerHTML = renderInventoryMinecraft(d.inventory, d.stats.selectedSlot);
    }
  } catch {
    document.getElementById('pmOverview').innerHTML = '<div class="empty">Failed to load player details</div>';
    document.getElementById('pmInventory').innerHTML = '<div class="empty">Failed to load inventory</div>';
  }
}

async function pmGiveXp() {
  if (!activePlayer) return;
  const amount = parseInt(document.getElementById('pmXpAmount').value, 10) || 0;
  const unit = document.getElementById('pmXpUnit').value;
  try {
    await apiJson('/api/player/' + encodeURIComponent(activePlayer) + '/xp', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ amount, unit, mode: 'add' }),
    });
    toast('XP command sent', '');
  } catch (e) {
    toast(e.message, 'leave');
  }
}

async function pmGiveItem() {
  if (!activePlayer) return;
  const item = document.getElementById('pmItemId').value.trim();
  const count = parseInt(document.getElementById('pmItemCount').value, 10) || 1;
  try {
    await apiJson('/api/player/' + encodeURIComponent(activePlayer) + '/give', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ item, count }),
    });
    toast('Give command sent', '');
  } catch (e) {
    toast(e.message, 'leave');
  }
}

async function pmHeal() {
  if (!activePlayer) return;
  const amount = parseInt(document.getElementById('pmHealthAmount').value, 10) || 8;
  try {
    await apiJson('/api/player/' + encodeURIComponent(activePlayer) + '/health', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ mode: 'heal', amount }),
    });
    toast('Heal command sent', '');
  } catch (e) {
    toast(e.message, 'leave');
  }
}

async function pmDamage() {
  if (!activePlayer) return;
  const amount = parseInt(document.getElementById('pmHealthAmount').value, 10) || 4;
  try {
    await apiJson('/api/player/' + encodeURIComponent(activePlayer) + '/health', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ mode: 'damage', amount }),
    });
    toast('Damage command sent', '');
  } catch (e) {
    toast(e.message, 'leave');
  }
}

async function pmSetHealth() {
  if (!activePlayer) return;
  const amount = parseInt(document.getElementById('pmHealthAmount').value, 10) || 20;
  try {
    await apiJson('/api/player/' + encodeURIComponent(activePlayer) + '/health', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ mode: 'set', amount }),
    });
    toast('Set health command sent', '');
  } catch (e) {
    toast(e.message, 'leave');
  }
}

async function pmFeed() {
  if (!activePlayer) return;
  try {
    await apiJson('/api/player/' + encodeURIComponent(activePlayer) + '/feed', { method: 'POST' });
    toast('Feed command sent', '');
  } catch (e) {
    toast(e.message, 'leave');
  }
}

async function pmRequestInventory() {
  if (!activePlayer) return;
  try {
    const base = '/api/player/' + encodeURIComponent(activePlayer);
    try {
      await apiJson(base + '/inventory/request', { method: 'POST' });
    } catch (e) {
      if (!/404/.test(String(e.message))) throw e;
      await apiJson(base + '/inventory', { method: 'POST' });
    }
    toast('Inventory requested in console output', '');
  } catch (e) {
    toast(e.message, 'leave');
  }
}

async function refreshMapOverlays() {
  try {
    const overlays = await (await fetch('/api/map/overlays')).json();
    mapOverlays = overlays;
    updateFollowPlayerOptions();
    if (followPlayerSelect.value) centerOnPlayer(followPlayerSelect.value);
    renderMap();
  } catch {}
}

async function requestLivePlayerPositions() {
  try {
    const d = await (await fetch('/api/map/request-player-positions', { method: 'POST' })).json();
    if (d && d.requested && d.count > 0) {
      await new Promise((r) => setTimeout(r, 350));
    }
  } catch {}
}

function mapFitToRegions() {
  const dpr = devicePixelRatio || 1;
  const rect = mapCanvas.getBoundingClientRect();
  const width = rect.width || mapCanvas.width / dpr || 1;
  const height = rect.height || mapCanvas.height / dpr || 1;
  if (mapMode === 'seed') {
    mapView = { x: 0, z: 0, zoom: 0.35 };
    return;
  }
  if (mapRegions.length === 0) {
    mapView = { x: 0, z: 0, zoom: 1 };
    return;
  }

  let minX = Infinity;
  let minZ = Infinity;
  let maxX = -Infinity;
  let maxZ = -Infinity;
  for (const r of mapRegions) {
    const x0 = r.x * 512;
    const z0 = r.z * 512;
    minX = Math.min(minX, x0);
    minZ = Math.min(minZ, z0);
    maxX = Math.max(maxX, x0 + 512);
    maxZ = Math.max(maxZ, z0 + 512);
  }
  const spanX = Math.max(512, maxX - minX);
  const spanZ = Math.max(512, maxZ - minZ);
  const pad = 40;
  const fitZoom = Math.min((width - pad) / spanX, (height - pad) / spanZ);
  mapView = {
    x: (minX + maxX) / 2,
    z: (minZ + maxZ) / 2,
    zoom: Math.max(0.08, Math.min(4, fitZoom)),
  };
}

function updateFollowPlayerOptions() {
  const players = (mapOverlays.players || []).slice().sort((a, b) => a.name.localeCompare(b.name));
  const prev = followPlayerSelect.value;
  const options = ['<option value="">none</option>']
    .concat(players.map((p) => `<option value="${esc(p.name)}">${esc(p.name)}${p.online ? ' (online)' : ''}</option>`));
  followPlayerSelect.innerHTML = options.join('');
  if (players.some((p) => p.name === prev)) followPlayerSelect.value = prev;
}

function centerOnPlayer(name) {
  const p = (mapOverlays.players || []).find((x) => x.name === name);
  if (!p) return;
  mapView.x = p.x;
  mapView.z = p.z;
  mapView.zoom = Math.max(mapView.zoom, 0.8);
}

async function loadMapTile(rx, rz) {
  const key = mapMode + ':' + rx + ',' + rz;
  if (mapTiles[key] || mapLoading.has(key)) return;
  mapLoading.add(key);
  document.getElementById('mapLoading').style.display = 'block';

  try {
    const url = mapMode === 'seed'
      ? `/api/map/seed-tile/${rx}/${rz}?v=${mapTileVersion}`
      : `/api/map/tile/${rx}/${rz}?v=${mapTileVersion}`;
    const res = await fetch(url);
    if (!res.ok) { mapLoading.delete(key); return; }
    const buf = await res.arrayBuffer();
    const rgb = new Uint8Array(buf);

    const offscreen = document.createElement('canvas');
    offscreen.width = 512;
    offscreen.height = 512;
    const octx = offscreen.getContext('2d');
    const imgData = octx.createImageData(512, 512);
    for (let i = 0; i < 512 * 512; i++) {
      imgData.data[i * 4] = rgb[i * 3];
      imgData.data[i * 4 + 1] = rgb[i * 3 + 1];
      imgData.data[i * 4 + 2] = rgb[i * 3 + 2];
      imgData.data[i * 4 + 3] = (rgb[i * 3] || rgb[i * 3 + 1] || rgb[i * 3 + 2]) ? 255 : 0;
    }
    octx.putImageData(imgData, 0, 0);
    mapTiles[key] = offscreen;
    renderMap();
  } catch {}

  mapLoading.delete(key);
  if (mapLoading.size === 0) document.getElementById('mapLoading').style.display = 'none';
}

function visibleRegionCoords(w, h) {
  const [tlx, tlz] = screenToWorld(0, 0);
  const [brx, brz] = screenToWorld(w, h);
  const minRx = Math.floor(Math.min(tlx, brx) / 512) - 1;
  const maxRx = Math.floor(Math.max(tlx, brx) / 512) + 1;
  const minRz = Math.floor(Math.min(tlz, brz) / 512) - 1;
  const maxRz = Math.floor(Math.max(tlz, brz) / 512) + 1;
  const regions = [];
  for (let rz = minRz; rz <= maxRz; rz++) {
    for (let rx = minRx; rx <= maxRx; rx++) {
      regions.push({ x: rx, z: rz });
    }
  }
  return regions;
}

function renderMap() {
  const dpr = devicePixelRatio || 1;
  const rect = mapCanvas.getBoundingClientRect();
  if (mapCanvas.width !== Math.round(rect.width * dpr) || mapCanvas.height !== Math.round(rect.height * dpr)) {
    mapCanvas.width = Math.round(rect.width * dpr);
    mapCanvas.height = Math.round(rect.height * dpr);
  }
  mapCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
  const w = rect.width, h = rect.height;

  mapCtx.fillStyle = '#0a0a0a';
  mapCtx.fillRect(0, 0, w, h);

  const regionsToDraw = mapMode === 'seed' ? visibleRegionCoords(w, h) : mapRegions;

  // Draw region tiles
  for (const r of regionsToDraw) {
    const [sx, sz] = worldToScreen(r.x * 512, r.z * 512);
    const size = 512 * mapView.zoom;

    // Skip if off-screen
    if (sx + size < 0 || sz + size < 0 || sx > w || sz > h) continue;

    const key = mapMode + ':' + r.x + ',' + r.z;
    if (mapTiles[key]) {
      mapCtx.imageSmoothingEnabled = mapView.zoom < 1;
      mapCtx.drawImage(mapTiles[key], sx, sz, size, size);
    } else {
      mapCtx.fillStyle = '#151515';
      mapCtx.fillRect(sx, sz, size, size);
      mapCtx.strokeStyle = '#222';
      mapCtx.lineWidth = 1;
      mapCtx.strokeRect(sx, sz, size, size);
      loadMapTile(r.x, r.z);
    }
  }

  // Chunk grid at high zoom
  if (mapView.zoom >= 2) {
    mapCtx.strokeStyle = 'rgba(255,255,255,0.04)';
    mapCtx.lineWidth = 1;
    const [tlx, tlz] = screenToWorld(0, 0);
    const [brx, brz] = screenToWorld(w, h);
    const startCX = Math.floor(tlx / 16) * 16;
    const startCZ = Math.floor(tlz / 16) * 16;
    for (let cx = startCX; cx <= brx; cx += 16) {
      const [sx] = worldToScreen(cx, 0);
      mapCtx.beginPath(); mapCtx.moveTo(sx, 0); mapCtx.lineTo(sx, h); mapCtx.stroke();
    }
    for (let cz = startCZ; cz <= brz; cz += 16) {
      const [, sz] = worldToScreen(0, cz);
      mapCtx.beginPath(); mapCtx.moveTo(0, sz); mapCtx.lineTo(w, sz); mapCtx.stroke();
    }
  }

  if (document.getElementById('toggleVillages').checked) {
    mapCtx.fillStyle = 'rgba(255, 214, 60, 0.95)';
    mapCtx.strokeStyle = 'rgba(0, 0, 0, 0.55)';
    mapCtx.lineWidth = 1;
    for (const v of mapOverlays.villages || []) {
      const [sx, sz] = worldToScreen(v.x, v.z);
      if (sx < -12 || sz < -12 || sx > w + 12 || sz > h + 12) continue;
      mapCtx.beginPath();
      mapCtx.rect(sx - 4, sz - 4, 8, 8);
      mapCtx.fill();
      mapCtx.stroke();
      if (mapView.zoom >= 0.5) {
        mapCtx.fillStyle = '#ffe89e';
        mapCtx.font = '11px monospace';
        mapCtx.fillText('Village', sx + 7, sz - 7);
        mapCtx.fillStyle = 'rgba(255, 214, 60, 0.95)';
      }
    }
  }

  if (document.getElementById('toggleStructures').checked) {
    const structureColors = {
      mansion: '#ff8f66',
      ancient_city: '#6ad0ff',
      stronghold: '#b39cff',
      trial_chambers: '#9de080',
      monument: '#66d6c2',
      outpost: '#d5a86f',
      fortress: '#ff6f6f',
      bastion: '#e07f4f',
      end_city: '#ff87ea',
      mineshaft: '#d6b98b',
      ruined_portal: '#8e70ff',
      shipwreck: '#8cb4d9',
      temple: '#d7d36f',
      village: '#ffd764',
    };
    mapCtx.lineWidth = 1;
    mapCtx.font = '11px monospace';
    for (const s of mapOverlays.structures || []) {
      if (s.type === 'village') continue;
      const [sx, sz] = worldToScreen(s.x, s.z);
      if (sx < -14 || sz < -14 || sx > w + 14 || sz > h + 14) continue;
      const color = structureColors[s.type] || '#bfbfbf';
      mapCtx.strokeStyle = 'rgba(0,0,0,0.65)';
      mapCtx.fillStyle = color;
      mapCtx.beginPath();
      mapCtx.moveTo(sx, sz - 7);
      mapCtx.lineTo(sx + 7, sz + 7);
      mapCtx.lineTo(sx - 7, sz + 7);
      mapCtx.closePath();
      mapCtx.fill();
      mapCtx.stroke();
      if (mapView.zoom >= 0.45) {
        mapCtx.fillStyle = '#f1f1f1';
        mapCtx.fillText(s.label || s.type, sx + 9, sz - 9);
      }
    }
  }

  if (document.getElementById('toggleSpawners').checked) {
    mapCtx.fillStyle = '#ff5b4d';
    mapCtx.strokeStyle = 'rgba(0,0,0,0.65)';
    mapCtx.lineWidth = 1;
    for (const s of mapOverlays.spawners || []) {
      const [sx, sz] = worldToScreen(s.x, s.z);
      if (sx < -8 || sz < -8 || sx > w + 8 || sz > h + 8) continue;
      mapCtx.beginPath();
      mapCtx.arc(sx, sz, 4, 0, Math.PI * 2);
      mapCtx.fill();
      mapCtx.stroke();
    }
  }

  if (document.getElementById('toggleSpawn').checked && mapOverlays.spawn) {
    const s = mapOverlays.spawn;
    const [sx, sz] = worldToScreen(s.x, s.z);
    if (sx > -14 && sz > -14 && sx < w + 14 && sz < h + 14) {
      mapCtx.strokeStyle = '#8cf2c4';
      mapCtx.lineWidth = 2;
      mapCtx.beginPath();
      mapCtx.moveTo(sx - 6, sz); mapCtx.lineTo(sx + 6, sz);
      mapCtx.moveTo(sx, sz - 6); mapCtx.lineTo(sx, sz + 6);
      mapCtx.stroke();
      if (mapView.zoom >= 0.35) {
        mapCtx.fillStyle = '#aef8d8';
        mapCtx.font = '11px monospace';
        mapCtx.fillText('Spawn', sx + 8, sz - 6);
      }
    }
  }

  if (document.getElementById('toggleRespawns').checked) {
    mapCtx.font = '11px monospace';
    for (const r of mapOverlays.respawns || []) {
      const [sx, sz] = worldToScreen(r.x, r.z);
      if (sx < -10 || sz < -10 || sx > w + 10 || sz > h + 10) continue;
      mapCtx.fillStyle = '#d594ff';
      mapCtx.strokeStyle = 'rgba(0,0,0,0.6)';
      mapCtx.lineWidth = 1;
      mapCtx.beginPath();
      mapCtx.rect(sx - 4, sz - 4, 8, 8);
      mapCtx.fill();
      mapCtx.stroke();
      if (mapView.zoom >= 0.45) {
        mapCtx.fillStyle = '#ebccff';
        mapCtx.fillText(`${r.name} spawn`, sx + 8, sz - 6);
      }
    }
  }

  if (document.getElementById('togglePlayers').checked) {
    mapCtx.font = '11px monospace';
    mapCtx.textBaseline = 'middle';
    for (const p of mapOverlays.players || []) {
      const [sx, sz] = worldToScreen(p.x, p.z);
      if (sx < -14 || sz < -14 || sx > w + 14 || sz > h + 14) continue;
      mapCtx.fillStyle = p.online ? '#3bda78' : '#8a8a8a';
      mapCtx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
      mapCtx.lineWidth = 2;
      mapCtx.beginPath();
      mapCtx.arc(sx, sz, 5, 0, Math.PI * 2);
      mapCtx.fill();
      mapCtx.stroke();
      if (mapView.zoom >= 0.28) {
        mapCtx.fillStyle = '#f2f2f2';
        mapCtx.fillText(p.name, sx + 8, sz);
      }
    }
  }

  // Origin crosshair
  const [cx, cy] = worldToScreen(0, 0);
  if (cx > -20 && cx < w + 20 && cy > -20 && cy < h + 20) {
    mapCtx.strokeStyle = 'rgba(255,255,255,0.5)';
    mapCtx.lineWidth = 1;
    mapCtx.beginPath();
    mapCtx.moveTo(cx - 10, cy); mapCtx.lineTo(cx + 10, cy);
    mapCtx.moveTo(cx, cy - 10); mapCtx.lineTo(cx, cy + 10);
    mapCtx.stroke();
  }

  const info = document.getElementById('mapInfo');
  const online = (mapOverlays.players || []).filter((p) => p.online).length;
  const regionText = mapMode === 'seed' ? 'seed preview' : `${mapRegions.length}`;
  const structs = (mapOverlays.structures || []).length;
  const spawners = (mapOverlays.spawners || []).length;
  info.textContent = `regions: ${regionText} | players: ${online}/${(mapOverlays.players || []).length} | villages: ${(mapOverlays.villages || []).length} | structures: ${structs} | dungeons: ${spawners}`;
}

// Toast
function toast(text, type) {
  const el = document.createElement('div');
  el.className = 'toast' + (type ? ' ' + type : '');
  el.textContent = text;
  document.body.appendChild(el);
  setTimeout(() => el.remove(), 2500);
}

window.addEventListener('DOMContentLoaded', () => {
  const saved = localStorage.getItem(TAB_KEY) || 'console';
  openTab(saved);
  const modalBackdrop = document.getElementById('playerModalBackdrop');
  if (modalBackdrop) {
    modalBackdrop.addEventListener('click', (e) => {
      if (e.target.id === 'playerModalBackdrop') closePlayerModal();
    });
  }
  bindInventoryTooltips();
});
</script>
<div class="modal-backdrop" id="playerModalBackdrop">
  <div class="modal" id="playerModal">
    <div class="modal-head">
      <div class="player-row">
        <img class="player-face" id="pmFace" alt="player" />
        <strong id="pmName">Player</strong>
      </div>
      <button onclick="closePlayerModal()">Close</button>
    </div>
    <div class="modal-grid">
      <div class="modal-card">
        <div class="section-title">Overview</div>
        <div id="pmOverview" class="empty">Loading...</div>
      </div>
      <div class="modal-card">
        <div class="section-title">Quick Actions</div>
        <div class="add-row">
          <input id="pmXpAmount" type="text" value="5" />
          <select id="pmXpUnit"><option value="levels">levels</option><option value="points">points</option></select>
          <button onclick="pmGiveXp()">Give XP</button>
        </div>
        <div class="add-row">
          <input id="pmItemId" type="text" placeholder="minecraft:diamond" style="flex:1" />
          <input id="pmItemCount" type="text" value="1" />
          <button onclick="pmGiveItem()">Give</button>
        </div>
        <div class="add-row">
          <input id="pmHealthAmount" type="text" value="8" />
          <button onclick="pmHeal()">Heal</button>
          <button class="btn-red" onclick="pmDamage()">Damage</button>
          <button onclick="pmSetHealth()">Set HP</button>
          <button onclick="pmFeed()">Feed</button>
        </div>
        <div class="add-row">
          <button onclick="pmRequestInventory()">Request Live Inventory To Console</button>
        </div>
      </div>
      <div class="modal-card" style="grid-column: 1 / -1;">
        <div class="section-title">Inventory Snapshot</div>
        <div id="pmInventory" class="empty">No data</div>
      </div>
    </div>
  </div>
</div>
<div class="inv-tooltip" id="invTooltip"></div>
</body>
</html>
